::: {.callout-tip}
## Application 3a: Param√©trisation du script

1. En s'inspirant de l'exemple ci-dessus üëÜÔ∏è,
cr√©er une variable `n_trees` qui peut √©ventuellement √™tre param√©tr√©e en ligne de commande
et dont la valeur par d√©faut est 20 ;
2. Tester cette param√©trisation en ligne de commande avec la valeur par d√©faut
puis 2, 10 et 50 arbres.
:::

L'exercice suivant permet de mettre en application le fait de param√©triser
un script en utilisant des variables d√©finies dans un fichier YAML. 


::: {.callout-tip}
## Application 3b: La configuration dans un fichier YAML

Nous allons mettre 4 param√®tres dans notre YAML. Celui-ci prendra la forme suivante:

```{.yaml filename="config.yaml"}
jeton_api: ####
data_path: ####
```

Avec `####` des valeurs √† remplacer.

1. Cr√©er √† la racine du projet un fichier `config.yaml` √† partir du
mod√®le üëÜÔ∏è ;
2. Rep√©rer les valeurs dans le code associ√© et compl√©ter.

Maintenant, nous allons exploiter ce fichier:

3. Pour √©viter d'avoir √† le faire plus tard,
cr√©er une fonction `import_yaml_config` qui prend en argument le
chemin d'un fichier `YAML`
et renvoie le contenu de celui-ci en _output_. Vous pouvez suivre
le conseil du chapitre sur la [Qualit√© du code](/chapters/code-quality.html)
en adoptant le _type hinting_ ;

<details>
<summary>Indice si vous ne trouvez pas comment lire un fichier `YAML`</summary>

Si le fichier s'appelle `toto.yaml`, vous pouvez l'importer de cette mani√®re:

```{python}
#| eval: false
with open("toto.yaml", "r", encoding="utf-8") as stream:
    dict_config = yaml.safe_load(stream)
```

</details>

4. Dans la fonction `import_yaml_config`,
cr√©er une condition logique pour tenir compte du fait que le YAML de configuration
peut ne pas exister[^fileexist] ;

<details>
<summary>Indice si vous ne savez comment conditionner la cr√©ation de la configuration √† l'existence du fichier</summary>

Voici la ligne qui peut vous aider. L'id√©al
est d'ins√©rer ceci dans `import_yaml_config`:

```{python}
#| eval: false
CONFIG_PATH = 'config.yaml'
config = {}
if os.path.exists(CONFIG_PATH):
    # lecture du fichier
```

</details>


5. Utiliser le canevas de code suivant pour cr√©er les variables ad√©quates

```{python}
#| eval: false
API_TOKEN = config.get("jeton_api")
TRAIN_PATH = config.get("train_path", "train.csv")
TEST_PATH = config.get("test_path", "test.csv")
TEST_FRACTION = config.get("test_fraction", .1)
```

et remplacer dans le code ;

5. Tester en ligne de commande que l'ex√©cution du fichier est toujours
sans erreur et sinon corriger ;
6. Refaire un diagnostic avec [`PyLint`](https://pylint.readthedocs.io/en/latest/)
et corriger les √©ventuels messages ;
7. Cr√©er un fichier `.gitignore` (cf. [Chapitre `Git`](/chapters/git.qmd)). Ajouter dans ce fichier `config.yaml`
car il ne faut pas committer ce fichier. Au passage ajouter `__pycache__/` au `.gitignore`[^pycache], cela
√©vitera d'avoir √† le faire ult√©rieurement ;
9. Cr√©er un fichier `README.md` o√π vous indiquez qu'il faut cr√©er un fichier `config.yaml` pour
pouvoir utiliser l'API. 

[^fileexist]: Ici, le jeton d'API n'est pas indispensable pour que le code
    fonctionne. Afin d'√©viter une erreur non n√©cessaire
    lorsqu'on automatisera le processus, on peut
    cr√©er une condition qui v√©rifie la pr√©sence ou non de ce fichier.
    Le script reste donc reproductible m√™me pour un utilisateur n'ayant pas le fichier
    `secrets.yaml`. 

[^pycache]: Il est normal d'avoir des dossiers `__pycache__` qui tra√Ænent en local : ils se cr√©ent automatiquement √† l'ex√©cution d'un script en `Python`. N√©anmoins, il ne faut pas associer ces fichiers √† `Git`, voil√† pourquoi on les ajoute au `.gitignore`.


:::


::: {.callout-caution collapse="true"}
## Checkpoint

```{.bash filename="terminal"}
git stash #<1>
git checkout appli3
```
1. Pour annuler les modifications depuis le dernier _commit_


![](/checkpoint.jpg){width=80% fig-align="center"}

:::